\section{Methods of Inquiry and Analysis}

\begin{figure}[t]
  \begin{center}

    \resizebox{\textwidth}{!}{
     \input{fig/arch.pdf_t}
   }
    \caption{Methodology overview.}
    \label{fig:overview}
  \end{center}
\end{figure}

\subsection{Overview} 

The diagram in Figure~\ref{fig:overview} illustrates the 
methodology we will use to achieve the aims of the proposal. 
The front end will take a BIP specification and produce
a BOP system $\B$. 
The subsystem selection will produce a subsystem$B'$ of $\B$. 

Structural analysis considers the subsystem $B'$ and builds
a wait-for graph $W_s$ for each reachable state $s$ of $B'$. 
In case $B'$ is found to be deadlock free, we conclude. 
In case $B'$ is found to be deadlock prone, we compute 
a counterexample. 

Semantic analysis takes $B'$ and considers the predicates
annotating the ports and interactions. 
It constructs an enablement abstraction around from 
port enablement and interaction enablement. 
The abstraction is expressed in a first order logic (FOL)
formula that we pass to an SMT SAT solver. 
The result of the SMT SAT solver refines the set of reachable 
states. 

The subsystem selection makes use of the counterexamples 
and the reachable states to
guide the construction of the next subsystem. 
The structural analysis also leverages the reachable state
results from the semantic analysis to improve its runtime. 

In what follows we provide detailed description of the 
different parts of our methodology and illustrate how 
the methodology will help us achieve the specific aims
of Section~\ref{sec:aims}



\subsection{Wait-for graphs}

Local deadlock denotes the state where a subset of the system components are deadlocked while the rest of the system can execute.
%
We characterize the waiting relations in a system by means of a {\em wait-for-graph}. 
If a component $\B_i$ is ready to execute an interaction $\act$ then there is an edge $\B_i ar \act$ from $\B_i$ to $\act$.
If a component $\B_i$ is not ready to execute an interaction $\act$ then there is an edge $\act \ar \B_i$ from $\act$ to $\B_i$.
A key point is that the wait-for graph depends on the current configuration (\ie the current ``global state'') of the system.
%
Components communicate and execute through interactions. 
An interaction is enabled to execute when all components that 
are parts of it are ready. 
So an edge from an interaction to a component in a wait-for-graph
is an AND edge. 
A component executes if any one of the interactions it is part of
executes. So an edge from a component to an interaction is an OR
edge. 
The wait-for graph therefore is an AND-OR graph. 
We will leverage this interesting structure to simplify the
check for deadlock freedom. 



\subsection{Supercycles}

We characterize a deadlock as a particular waiting pattern in a wait-for graph.
Roughly speaking, a supercycle $\SC$ is a subset of the components and interactions such that every component and interaction in $\SC$ is blocked by
the other components and interactions in $\SC$. 
An interaction $\act$ is blocked by $\SC$ iff there is some participant $\B_j$ of $\act$ such that $\B_j$ is in $\SC$ and $\B_j$ is not ready to
execute $\act$.
A component $\B_i$ is blocked by $\SC$ iff every interaction $\act$ that $\B_i$ is ready to execute happens to be in $\SC$.
A supercycle is the AND-OR generalization of a simple cycle.



\subsection{Preventing the formation of supercycles}

A supercycle implies a deadlock, and so is stable: once a supercycle forms, it persists forever.
Suppose there is no supercycle in global state $t$, and an interaction $\act$ is executed which leads to a new global state $s$ in which a supercycle $\SC$
exists. 
Then we show that some participant $\B_i$ of $\act$ must be in the newly formed supercycle $\SC$. 
We exploit this fact to impose constraints on the effects of executing $\act$, which prevent the formation of the supercycle $\SC$.

\subsection{Aim 2: Counterexample based refinement} 

When the method detects a supercycle, it issues an alarm of a 
deadlock prone system. 
The supercycle characterizes the deadlock as an interdependent 
set of components and interactions
at a specific state. 
We will extend the method to compute a counterexample
that illustrates the deadlock. 
First, we will compute an execution path that leads 
to the reachable state from the initial state. 
Then we will translate the set of components and interactions
into a sequence of interactions that will lead to the deadlock. 

The counterexample can also be used to devise a method to
select the next subsystem. 
We will inspect the variables that are assigned
in the counterexample and those that are not assigned. 
The assigned variables force a deadlock and the values of the
other variables do not matter. 
We will explore extending the subsystem in the direction of 
the assigned 
variables instead of extending it in all directions uniformly 
as the current method does. 

\subsection{Aim 3: Enablement abstraction } 

The method currently iterates over all reachable states of
a subsystem, constructs a wait-for graph structure and 
performs a supercycle check. 
The reachable states in a subsystem are an over-approximation
of the reachable states in the whole system. 

We will extend the method to tighten this over-approximation. 
Interactions connect components through ports. 
%
We will extend the formalization to include predicates 
that annotate the ports and the interactions. 
These predicates are Boolean expressions that range over the
variables of the system and all fall within 
the Presburger arithmetic theory. 
%
We will encode each state of a component with a Boolean 
variable.
Then, we perform a strongest postcondition computation to 
obtain a system of equations that constrains the reachable 
states.
%
The system of equations can now eliminate some of the states
we used to visit in our supercycle checks. 

The system of equations can also act as an enablement abstraction.
The wait-for graph currently contains component and interaction nodes. 
We can extend it to contain ports. 
The AND-OR structure becomes now an AND-$\phi$-OR structure
where $\phi$ is a first order logic formula projected from
the system of equations over a specific port. 
This allows the composition of formula that indicates
a tighter supercycle check. 
In case the formula has a satisfying assignment, then
a supercycle exists. 

We will use SMT solvers to check whether a state 
satisfies the system of equations for reachable state 
enumeration. 
We will also use SMT solvers to perform a symbolic
supercycle check.

\subsection{Aim 4: Parameterized systems} 

A parametrized system $B=\B_1 \pl B_1 \ldots \pl B_1$ is a 
composite system of $N>1$ $B_1$ components. 
Our method naturally extends to address parametrized systems 
of a specific size $N=n_0$. 

An interesting question is that given a parametrized system $B$, 
can we devise a method that answers the deadlock freedom
question for any $N$. 

We will explore ways to extend our method to answer the 
parametrized deadlock freedom question. 
We can start by checking the symmetry of the connections between
the $B_1$ components.
The symmetry can allow us to generalize the method. 
For example, if all $B^3=B_1\pl B_1 \pl B_1$ 
($3-$component subsystems) of $B$ are equivalent,
then deadlock freedom of $B^3$ implies deadlock freedom 
of $B$. 


\subsection{Aim 5: Structural checks for other safety properties} 
\subsection{Aim 6: Benchmarking and validation } 
