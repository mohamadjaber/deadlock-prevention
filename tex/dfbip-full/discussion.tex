
\paragraph{Related work.} 
The notions of wait-for-graph and supercycle \cite{AC05,AE98}
were initially defined for a shared memory program
$P = P_1 \pl \cdots \pl P_K$ in \emph{pairwise normal form}: a binary
symmettric relation $I$ specifies the directly interacting pairs
(``neighbors'') $\set{P_i, P_j}$.
If $P_i$ has neighbors $P_j$ and $P_k$, then 
the code in $P_i$ that interacts with $P_j$ is expressed separately from
the code in $P_i$ that interacts with $P_k$. 
These synchronization codes are executed synchronously and
atomically, so the grain of atomicity is proportional to the
degree of $I$.
%
Attie and Chockler \cite{AC05} give two polynomial time 
methods for deadlock freedom.
The first checks subsystems consisting of three
processes. The second computes the wait-for-graphs of all pair subsystems $P_i \pl P_j$,
and takes their union, for all pairs
and all reachable states of each pair.
%Both methods consider in-paths and out-paths of length at most 2. The second
%method in addition considers the maximal strong components of $\mathcal{W}$. 
The first method considers only wait-for-paths of length $\le 2$. 
%due to the construction of $\mathcal{W}$, 
The second method is prone to false negatives,
%again due to $\mathcal{W}$, 
because wait-for edges generated by different states are
all merged together, which can result in spurious supercycles


G{\"o}ssler and Sifakis \cite{GS03} use a BIP-like
formalism, Interaction Models. %, which uses multiparty interactions and
%connectors to specify synchronization between components. 
They present a criterion for global deadlock freedom, based on 
%a dependency graph, which is %(like our wait-for-graph)
an and-or graph with components and constraints as the two sets of nodes. A
constraint gives the condition
under which a component is blocked. Edges are labeled with conjuncts
of the constraints.  Deadlock freedom is checked by traversing every
cycle, taking the conjunction of all the
conditions labeling its edges, and verifying that this conjunction is
always false, \ie verifying the absence of cyclical blocking.
No complexity bounds are given.
%
Martens and Majster-Cederbaum~\cite{MM12} present a polynomial time
checkable deadlock freedom condition based on structural restrictions:
``the communication structure between the components is given by a
tree.'' This restriction allows them to analyze only pair systems.
%
Aldini and Bernardo \cite{AB03} use a 
formalism based on process algebra. They check deadlock by analysing cycles in
the connections between software components, and claim scalability, but no
complexity bounds are given.

Roscoe and Dathi \cite{RD87} present several rules for deadlock freedom of CSP programs. The basis for these rules is to define ``variant function'' that maps
the state of each process to a partially ordered set. The first rule requires to establish that, if $P_i$ waits for $P_j$, then the value of $P_i$'s state is greater than the value of
$P_j$'s state. This precludes the formation of wait-for cycles, and therefore of deadlock. They treat several examples, including a self-timed
systolic array (in 2 and 3 dimensions), dining philosophers, and a message switching network.
They generalize the first rule to exploit ``disconnecting edges'' (whose removal partitions the network into disconected components) to decompose the proof of deadlock freedom
into showing that each disconnected component is deadlock-free, and also to weaken the restriction on the variant function so that it only has to
decrease for at least one edge on each wait-for cycle.



Brookes and Roscoe~\cite{brookes91deadlockFreedom} provide criteria for
deadlock freedom of CSP programs based on structural and behavioral restrictions
combined with analysis of pair systems.
No implementation, or complexity bounds, are given.



We compared our implementation \ldfctool to D-Finder 2~\cite{DFinder2}. D-Finder 2
computes a finite-state abstraction for each component, which it uses
to compute a global invariant $I$. It then checks if $I$ 
implies deadlock freedom.  Unlike \ldfctool, D-Finder 2 
handles infinite state systems.
However, \ldfctool had superior running time for
dining philosophers and gas station (both finite-state).


All the above methods verify global (and not local) deadlock-freedom.
Our method verifies both.
Also, our approach makes no structural restriction at all on the system being
checked for deadlock.


\paragraph{Discussion.}
Our approach has the following advantages:
\begin{description}

\item[Local and global deadlock] Our method shows that no subset of processes
  can be deadlocked, \ie absence of both local and global deadlock. 

\item[Check works for realistic formalism]   By applying the approach to BIP, we
provide an efficient deadlock-freedom check within a formalism from
which efficient distributed implementations can be generated
\cite{BonakdarpourBJQS10b}.  

\item[Locality] If a component $B_i$ is modified, or is added to an
  existing system, then $\LDFC(a, \l)$ only has to
  be re-checked for $B_i$ and components within distance $\l$ of $B_i$.
  A condition whose evaluation considers the entire
  system at once, \eg \cite{AB03,DFinder2,GS03}
  would have to be re-checked for the entire system. 

\item[Easily parallelizable] Since the checking of each subsystem $\dsk{a}{\l}$
  is independent of the others, the checks can be carried out in parallel. Hence
  our method can be easily parallelized and distributed, for speedup, if needed.
  Alternatively, performing the checks sequentially
  minimizes the amount of memory needed. 

\item[Framework aspect] Supercycles and in/out-depth provide a \emph{framework} for
  deadlock-freedom. Conditions more general and/or discriminating than
  the one presented here 
  should be devisable in this framework. This is a topic for future work.

\end{description}


\paragraph{Further work.} 
Our implementation uses explicit state enumeration. % to evaluate $\LDFC(a, \l)$.
Using BDD's may improve the running time 
when $\LDFC(a, \l)$ holds only for large $\l$.
%, since the time to check $\LDFC(a, \l)$ grows exponentialy with $\l$, in general.
%
An enabled port $p$ enables all interactions containing $p$.
Deadlock-freedom conditions based on ports could exploit
this interdepence among interaction enablement.
%
Our implementation should produce \emph{counterexamples} when a system
fails to satisfy $\LDFC(a, \l)$.
%
\emph{Design rules} for ensuring $\LDFC(a, \l)$ will help users to
produce deadlock-free systems, and also to interpret counterexamples.
%
A \emph{fault} may create a deadlock,  \ie a supercycle, by creating 
wait-for-edges that would not normally arise.
Tolerating a fault that creates up to $f$ such spurious wait-for-edges 
requires that there do not arise during normal
(fault-free) operation subgraphs of $\wfg{B}{s}$ that can be made into a
supercycle by adding $f$ edges. 
We will investigate criteria for preventing formation of such subgraphs.
%
Methods for evaluating $\LDFC(a, \l)$ on \emph{infinite state} systems will be
devised, \eg, by extracting proof obligations and verifying using SMT solvers.
%This verifies local deadlock freedom, which, unlike global deadlock freedom,
%cannot be succinctly expressed in first order logic.
%
We will extend our method to \emph{Dynamic BIP},
\cite{DBLP:conf/soco/BozgaJMS12}, where participants can add and remove
interactions at run time.


